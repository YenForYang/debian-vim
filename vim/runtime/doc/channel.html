<HTML>
<HEAD>
<META HTTP-EQUIV="Content-type" content="text/html; charset=ISO-8859-1">
<TITLE>Vim documentation: channel</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1>Vim documentation: channel</H1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="channel.txt"></A><B>channel.txt</B>*      For Vim version 8.1.  Last change: 2018 Apr 18


		  VIM REFERENCE MANUAL	  by <A HREF="intro.html#Bram">Bram</A> <A HREF="intro.html#Moolenaar">Moolenaar</A>



		      Inter-process communication		*<A NAME="channel"></A><B>channel</B>*

Vim uses channels to communicate with other processes.

A <A HREF="#channel">channel</A> uses a socket or pipes.			*<A NAME="socket-interface"></A><B>socket-interface</B>*
<A HREF="eval.html#Jobs">Jobs</A> can be used to start processes and communicate with them.
The Netbeans interface also uses a <A HREF="#channel">channel</A>. |<A HREF="netbeans.html#netbeans">netbeans</A>|

1. Overview				|<A HREF="#job-channel-overview">job-channel-overview</A>|
2. <A HREF="eval.html#Channel">Channel</A> demo				|<A HREF="#channel-demo">channel-demo</A>|
3. Opening a channel			|<A HREF="#channel-open">channel-open</A>|
4. Using a JSON or JS channel		|<A HREF="#channel-use">channel-use</A>|
5. <A HREF="eval.html#Channel">Channel</A> commands			|<A HREF="#channel-commands">channel-commands</A>|
6. Using a RAW or NL channel		|<A HREF="#channel-raw">channel-raw</A>|
7. More channel <A HREF="eval.html#functions">functions</A>		|<A HREF="#channel-more">channel-more</A>|
8. Starting a job with a <A HREF="#channel">channel</A>	|<A HREF="#job-start">job-start</A>|
9. Starting a job without a channel	|<A HREF="#job-start-nochannel">job-start-nochannel</A>|
10. <A HREF="eval.html#Job">Job</A> options				|<A HREF="#job-options">job-options</A>|
11. Controlling a job			|<A HREF="#job-control">job-control</A>|
12. Using a prompt buffer		|<A HREF="#prompt-buffer">prompt-buffer</A>|

{Vi does not have any of these features}
{only when compiled with the |<A HREF="various.html#+channel">+channel</A>| feature for channel stuff}
	You can check this with: `has('channel')`
{only when compiled with the |<A HREF="various.html#+job">+job</A>| feature for job stuff}
	You can check this with: `has('job')`

==============================================================================

1. Overview						*<A NAME="job-channel-overview"></A><B>job-channel-overview</B>*

There are four main types of jobs:
1. A daemon, serving several Vim instances.
   Vim connects to <A HREF="motion.html#it">it</A> with a socket.
2. One <A HREF="#job">job</A> working with one Vim instance, asynchronously.
   Uses a socket or pipes.
3. A <A HREF="#job">job</A> performing some work for a short time, asynchronously.
   Uses a socket or pipes.
4. Running a <A HREF="change.html#filter">filter</A>, synchronously.
   Uses pipes.

For when using sockets See |<A HREF="#job-start">job-start</A>|, |<A HREF="#job-start-nochannel">job-start-nochannel</A>| and
|<A HREF="#channel-open">channel-open</A>|.  For 2 and 3, one or more jobs using pipes, see |<A HREF="#job-start">job-start</A>|.
For 4 use the &quot;:{range}!cmd&quot; command, see |<A HREF="change.html#filter">filter</A>|.

Over the socket and pipes these protocols are available:
RAW	nothing known, Vim cannot tell where a message ends
NL	every message ends in a NL (newline) character
JSON	JSON encoding |<A HREF="eval.html#json_encode()">json_encode()</A>|
JS	JavaScript style JSON-like encoding |<A HREF="eval.html#js_encode()">js_encode()</A>|

Common combination are:
- Using a <A HREF="#job">job</A> connected through pipes in NL mode.  E.g., to run a style
  checker and receive <A HREF="message.html#errors">errors</A> and warnings.
- Using a daemon, connecting over a socket in JSON mode.  E.g. to lookup
  cross-references in a database.

==============================================================================

2. <A HREF="eval.html#Channel">Channel</A> demo				*<A NAME="channel-demo"></A><B>channel-demo</B>* *<A NAME="demoserver.py"></A><B>demoserver.py</B>*

This requires <A HREF="if_pyth.html#Python">Python</A>.  The demo program can be found in
$VIMRUNTIME/tools/demoserver.py
Run <A HREF="motion.html#it">it</A> in one <A HREF="terminal.html#terminal">terminal</A>.  We will call this T1.

Run Vim in another <A HREF="terminal.html#terminal">terminal</A>.  Connect to the demo server with:
<B>	let channel = ch_open('localhost:8765')</B>

In T1 you should see:
<B><FONT COLOR="PURPLE">	=== socket opened === </FONT></B>

You can now send a message to the server:
<B>	echo ch_evalexpr(channel, 'hello!')</B>

The message is received in T1 and a response is sent back to Vim.
You can see the raw <A HREF="message.html#messages">messages</A> in T1.  What Vim sends is:
<B><FONT COLOR="PURPLE">	[1,"hello!"] </FONT></B>
And the response is:
<B><FONT COLOR="PURPLE">	[1,"got it"] </FONT></B>
The number will increase every time you send a message.

The server can send a command to Vim.  Type this on T1 (literally, including
the quotes):
<B><FONT COLOR="PURPLE">	["ex","echo 'hi there'"] </FONT></B>
And you should see the message in Vim. You can move the cursor a <A HREF="motion.html#word">word</A> forward:
<B><FONT COLOR="PURPLE">	["normal","w"] </FONT></B>

To handle asynchronous communication a callback needs to be used:
<B>	func MyHandler(channel, msg)</B>
<B>	  echo "from the handler: " . a:msg</B>
<B>	endfunc</B>
<B>	call ch_sendexpr(channel, 'hello!', {'callback': "MyHandler"})</B>
Vim will not wait for a response.  Now the server can send the response later
and MyHandler will be invoked.

Instead of giving a callback with every send call, <A HREF="motion.html#it">it</A> can also be specified
when opening the <A HREF="#channel">channel</A>:
<B>	call ch_close(channel)</B>
<B>	let channel = ch_open('localhost:8765', {'callback': "MyHandler"})</B>
<B>	call ch_sendexpr(channel, 'hello!')</B>

When trying out channels it's useful to see what is going on.  You can tell
Vim to write lines in log file:
<B>	call ch_logfile('channellog', 'w')</B>
See |<A HREF="eval.html#ch_logfile()">ch_logfile()</A>|.

==============================================================================

3. Opening a <A HREF="#channel">channel</A>					*<A NAME="channel-open"></A><B>channel-open</B>*

To open a <A HREF="#channel">channel</A>:
<B>    let channel = ch_open({address} [, {options}])</B>
<B>    if ch_status(channel) == "open"</B>
<B>      " use the channel</B>

Use |<A HREF="eval.html#ch_status()">ch_status()</A>| to see if the <A HREF="#channel">channel</A> could be opened.

<A HREF="cmdline.html#{address}">{address}</A> has the form &quot;hostname:port&quot;.  E.g., &quot;localhost:8765&quot;.


{options} is a dictionary with optional entries:	*<A NAME="channel-open-options"></A><B>channel-open-options</B>*


&quot;mode&quot; can be:						*<A NAME="channel-mode"></A><B>channel-mode</B>*
	&quot;json&quot; - Use JSON, see below; most convenient way. Default.
	&quot;js&quot;   - Use JS (JavaScript) encoding, more efficient than JSON.
	&quot;nl&quot;   - Use <A HREF="message.html#messages">messages</A> that end in a NL character
	&quot;raw&quot;  - Use raw <A HREF="message.html#messages">messages</A>

						*<A NAME="channel-callback"></A><B>channel-callback</B>* *<A NAME="E921"></A><B>E921</B>*
&quot;callback&quot;	A function that is called when a message is received that is
		not handled otherwise.  It gets two arguments: the <A HREF="#channel">channel</A>
		and the received message. Example:
<B>	func Handle(channel, msg)</B>
<B>	  echo 'Received: ' . a:msg</B>
<B>	endfunc</B>
<B>	let channel = ch_open("localhost:8765", {"callback": "Handle"})</B>
 
		When &quot;mode&quot; is &quot;json&quot; or &quot;js&quot; the &quot;msg&quot; argument is the body
		of the received message, converted to Vim types.
		When &quot;mode&quot; is &quot;nl&quot; the &quot;msg&quot; argument is one message,
		excluding the NL.
		When &quot;mode&quot; is &quot;raw&quot; the &quot;msg&quot; argument is the whole message
		<A HREF="motion.html#as">as</A> a <A HREF="eval.html#string">string</A>.

		For all callbacks: Use |<A HREF="eval.html#function()">function()</A>| to bind <A HREF="motion.html#it">it</A> to arguments
		and/or a <A HREF="eval.html#Dictionary">Dictionary</A>.  Or use the form &quot;dict.function&quot; to bind
		the <A HREF="eval.html#Dictionary">Dictionary</A>.

		Callbacks are only called at a &quot;safe&quot; moment, usually when Vim
		is waiting for the user to type a character.  Vim does not use
		multi-threading.


							*<A NAME="close_cb"></A><B>close_cb</B>*
&quot;<A HREF="#close_cb">close_cb</A>&quot;	A function that is called when the <A HREF="#channel">channel</A> gets closed, other
		than by calling <A HREF="eval.html#ch_close()">ch_close()</A>.  It should be defined like this:
<B>	func MyCloseHandler(channel)</B>
 		Vim will invoke callbacks that handle data before invoking
		<A HREF="#close_cb">close_cb</A>, thus when this function is called no more data will
		be passed to the callbacks.

							*<A NAME="channel-drop"></A><B>channel-drop</B>*
&quot;drop&quot;		Specifies when to drop <A HREF="message.html#messages">messages</A>:
		    &quot;auto&quot;	When there is no callback to handle a message.
				The &quot;<A HREF="#close_cb">close_cb</A>&quot; is also considered for this.
		    &quot;never&quot;	All <A HREF="message.html#messages">messages</A> will be kept.


							*<A NAME="channel-noblock"></A><B>channel-noblock</B>*
&quot;noblock&quot;	Same effect <A HREF="motion.html#as">as</A> |<A HREF="#job-noblock">job-noblock</A>|.  Only matters for <A HREF="editing.html#writing">writing</A>.


							*<A NAME="waittime"></A><B>waittime</B>*
&quot;<A HREF="#waittime">waittime</A>&quot;	The time to wait for the connection to be made in
		milliseconds.  A negative number waits forever.

		The default is zero, don't wait, which is useful if a local
		server is supposed to be running already.  On <A HREF="os_unix.html#Unix">Unix</A> Vim
		actually uses a 1 msec timeout, that is required on many
		systems.  Use a larger value for a remote server, e.g.  10
		msec at least.

							*<A NAME="channel-timeout"></A><B>channel-timeout</B>*
&quot;timeout&quot;	The time to wait for a request when blocking, E.g. when using
		<A HREF="eval.html#ch_evalexpr()">ch_evalexpr()</A>.  In milliseconds.  The default is 2000 (2
		seconds).

When &quot;mode&quot; is &quot;json&quot; or &quot;js&quot; the &quot;callback&quot; is optional.  When omitted <A HREF="motion.html#it">it</A> is
only possible to receive a message after sending one.

To change the <A HREF="#channel">channel</A> options after opening <A HREF="motion.html#it">it</A> use |<A HREF="eval.html#ch_setoptions()">ch_setoptions()</A>|.  The
arguments are similar to what is passed to |<A HREF="eval.html#ch_open()">ch_open()</A>|, but &quot;<A HREF="#waittime">waittime</A>&quot; cannot
be given, since that only applies to opening the <A HREF="#channel">channel</A>.

For example, the handler can be added or changed:
<B>    call ch_setoptions(channel, {'callback': callback})</B>
When &quot;callback&quot; is empty (zero or an empty <A HREF="eval.html#string">string</A>) the handler is removed.

After a callback has been invoked Vim will update the screen and put the
cursor back where <A HREF="motion.html#it">it</A> belongs.  Thus the callback should not need to <A HREF="diff.html#do">do</A>
`:redraw`.

The timeout can be changed:
<B>    call ch_setoptions(channel, {'timeout': msec})</B>
 

							  *<A NAME="channel-close"></A><B>channel-close</B>* *<A NAME="E906"></A><B>E906</B>*
Once done with the <A HREF="#channel">channel</A>, disconnect <A HREF="motion.html#it">it</A> like this:
<B>    call ch_close(channel)</B>
When a socket is used this will close the socket for both directions.  When
pipes are used (stdin/stdout/stderr) they are all closed.  This might not be
what you want!  Stopping the <A HREF="#job">job</A> with <A HREF="eval.html#job_stop()">job_stop()</A> might be better.
All readahead is discarded, callbacks will no longer be invoked.

Note that a <A HREF="#channel">channel</A> is closed in three stages:
  - The I/O ends, log message: &quot;Closing channel&quot;. There can still be queued
    <A HREF="message.html#messages">messages</A> to read or callbacks to invoke.
  - The readahead is cleared, log message: &quot;Clearing channel&quot;.  Some <A HREF="eval.html#variables">variables</A>
    may still reference the <A HREF="#channel">channel</A>.
  - The <A HREF="#channel">channel</A> is freed, log message: &quot;Freeing channel&quot;.

When the <A HREF="#channel">channel</A> can't be opened you will get an error message.  There is a
difference between <A HREF="os_win32.html#MS-Windows">MS-Windows</A> and <A HREF="os_unix.html#Unix">Unix</A>: On <A HREF="os_unix.html#Unix">Unix</A> when the port doesn't exist
<A HREF="eval.html#ch_open()">ch_open()</A> fails quickly.  On <A HREF="os_win32.html#MS-Windows">MS-Windows</A> &quot;<A HREF="#waittime">waittime</A>&quot; applies.

*<A NAME="E898"></A><B>E898</B>* *<A NAME="E901"></A><B>E901</B>* *<A NAME="E902"></A><B>E902</B>*

If there is an error reading or <A HREF="editing.html#writing">writing</A> a <A HREF="#channel">channel</A> <A HREF="motion.html#it">it</A> will be closed.

*<A NAME="E630"></A><B>E630</B>* *<A NAME="E631"></A><B>E631</B>* 

==============================================================================

4. Using a JSON or JS <A HREF="#channel">channel</A>					*<A NAME="channel-use"></A><B>channel-use</B>*

If mode is JSON then a message can be sent synchronously like this:
<B>    let response = ch_evalexpr(channel, {expr})</B>
This awaits a response from the other side.

When mode is JS this works the same, except that the <A HREF="message.html#messages">messages</A> use
JavaScript encoding.  See |<A HREF="eval.html#js_encode()">js_encode()</A>| for the difference.

To send a message, without handling a response or letting the <A HREF="#channel">channel</A> callback
handle the response:
<B>    call ch_sendexpr(channel, {expr})</B>

To send a message and letting the response handled by a specific function,
asynchronously:
<B>    call ch_sendexpr(channel, {expr}, {'callback': Handler})</B>

Vim will match the response with the request using the message ID.  Once the
response is received the callback will be invoked.  Further responses with the
same ID will be ignored.  If your server sends back multiple responses you
need to send them with ID zero, they will be passed to the <A HREF="#channel">channel</A> callback.

The {expr} is converted to JSON and wrapped in an array.  An example of the
message that the receiver will get when {expr} is the <A HREF="eval.html#string">string</A> &quot;hello&quot;:
<B><FONT COLOR="PURPLE">	[12,"hello"] </FONT></B>

The format of the JSON sent is:
    [{number},{expr}]

In which {number} is different every time.  It must be used in the response
(if any):

    [{number},{response}]

This way Vim knows which sent message matches with which received message and
can call the right handler.  Also when the <A HREF="message.html#messages">messages</A> arrive out of order.

A newline character is terminating the JSON text.  This can be used to
separate the read text.  For example, in <A HREF="if_pyth.html#Python">Python</A>:
	splitidx = read_text.find('\n')
	message = read_text[:splitidx]
	rest = read_text[splitidx + 1:]

The sender must always send valid JSON to Vim.  Vim can check for the end of
the message by parsing the JSON.  It will only accept the message if the end
was received.  A newline after the message is optional.

When the process wants to send a message to Vim without first receiving a
message, <A HREF="motion.html#it">it</A> must use the number zero:
    [0,{response}]

Then <A HREF="#channel">channel</A> handler will then get {response} converted to Vim types.  If the
<A HREF="#channel">channel</A> does not have a handler the message is dropped.

It is also possible to use <A HREF="eval.html#ch_sendraw()">ch_sendraw()</A> and <A HREF="eval.html#ch_evalraw()">ch_evalraw()</A> on a JSON or JS
<A HREF="#channel">channel</A>.  The caller is then completely responsible for correct encoding and
decoding.

==============================================================================

5. <A HREF="eval.html#Channel">Channel</A> commands					*<A NAME="channel-commands"></A><B>channel-commands</B>*

With a JSON <A HREF="#channel">channel</A> the process can send commands to Vim that will be
handled by Vim internally, <A HREF="motion.html#it">it</A> does not require a handler for the <A HREF="#channel">channel</A>.


Possible commands are:				*<A NAME="E903"></A><B>E903</B>* *<A NAME="E904"></A><B>E904</B>* *<A NAME="E905"></A><B>E905</B>*
    [&quot;redraw&quot;, {forced}]
    [&quot;ex&quot;,     {Ex command}]
    [&quot;normal&quot;, {Normal mode command}]
    [&quot;expr&quot;,   {expression}, {number}]
    [&quot;expr&quot;,   {expression}]
    [&quot;call&quot;,   {func name}, {argument list}, {number}]
    [&quot;call&quot;,   {func name}, {argument list}]

With all of these: Be careful what these commands <A HREF="diff.html#do">do</A>!  You can easily
interfere with what the user is doing.  To avoid trouble use |<A HREF="eval.html#mode()">mode()</A>| to check
that the editor is in the expected state.  E.g., to send keys that must be
inserted <A HREF="motion.html#as">as</A> text, not executed <A HREF="motion.html#as">as</A> a command:
<B><FONT COLOR="PURPLE">    ["ex","if mode() == 'i' | call feedkeys('ClassName') | endif"] </FONT></B>

Errors in these commands are normally not reported to avoid them messing up
the display.  If you <A HREF="diff.html#do">do</A> want to see them, set the <A HREF="options.html#'verbose'">'verbose'</A> option to 3 or
higher.


<B><FONT COLOR="PURPLE">Command "redraw" </FONT></B>

The other commands <A HREF="diff.html#do">do</A> not update the screen, so that you can send a sequence
of commands without the cursor moving around.  You must end with the &quot;redraw&quot;
command to show any changed text and show the cursor where <A HREF="motion.html#it">it</A> belongs.

The argument is normally an empty <A HREF="eval.html#string">string</A>:
<B><FONT COLOR="PURPLE">	["redraw", ""] </FONT></B>
To first clear the screen pass &quot;force&quot;:
<B><FONT COLOR="PURPLE">	["redraw", "force"] </FONT></B>


<B><FONT COLOR="PURPLE">Command "ex" </FONT></B>

The &quot;<A HREF="starting.html#ex">ex</A>&quot; command is executed <A HREF="motion.html#as">as</A> any <A HREF="intro.html#Ex">Ex</A> command.  There is no response for
completion or error.  You could use <A HREF="eval.html#functions">functions</A> in an |<A HREF="eval.html#autoload">autoload</A>| <A HREF="usr_41.html#script">script</A>:
	[&quot;ex&quot;,&quot;call myscript#MyFunc(arg)&quot;]

You can also use &quot;call |feedkeys()|&quot; to insert any key sequence.

When there is an error a message is written to the <A HREF="#channel">channel</A> log, if <A HREF="motion.html#it">it</A> exists,
and <A HREF="eval.html#v:errmsg">v:errmsg</A> is set to the error.


<B><FONT COLOR="PURPLE">Command "normal" </FONT></B>

The &quot;normal&quot; command is executed like with &quot;:normal!&quot;, commands are not
mapped.  Example to open the <A HREF="fold.html#folds">folds</A> under the cursor:
	[&quot;normal&quot; &quot;<A HREF="fold.html#zO">zO</A>&quot;]


<B><FONT COLOR="PURPLE">Command "expr"  with response </FONT></B>

The &quot;<A HREF="eval.html#expr">expr</A>&quot; command can be used to get the result of an <A HREF="eval.html#expression">expression</A>.  For
example, to get the number of lines in the current buffer:
<B><FONT COLOR="PURPLE">	["expr","line('$')", -2] </FONT></B>

It will send back the result of the <A HREF="eval.html#expression">expression</A>:
<B><FONT COLOR="PURPLE">	[-2, "last line"] </FONT></B>
The format is:
	[{number}, {result}]

Here {number} is the same <A HREF="motion.html#as">as</A> what was in the request.  Use a negative number
to avoid confusion with message that Vim sends.  Use a different number on
every request to be able to match the request with the response.

{result} is the result of the evaluation and is JSON encoded.  If the
evaluation fails or the result can't be encoded in JSON <A HREF="motion.html#it">it</A> is the <A HREF="eval.html#string">string</A>
&quot;ERROR&quot;.


<B><FONT COLOR="PURPLE">Command "expr" without a response </FONT></B>

This command is similar to &quot;<A HREF="eval.html#expr">expr</A>&quot; above, but does not send back any response.
Example:
<B><FONT COLOR="PURPLE">	["expr","setline('$', ['one', 'two', 'three'])"] </FONT></B>
There is no third argument in the request.


<B><FONT COLOR="PURPLE">Command "call" </FONT></B>

This is similar to &quot;<A HREF="eval.html#expr">expr</A>&quot;, but instead of passing the whole <A HREF="eval.html#expression">expression</A> <A HREF="motion.html#as">as</A> a
<A HREF="eval.html#string">string</A> this passes the name of a function and a <A HREF="eval.html#list">list</A> of arguments.  This
avoids the conversion of the arguments to a <A HREF="eval.html#string">string</A> and escaping and
concatenating them.  Example:
<B><FONT COLOR="PURPLE">	["call", "line", ["$"], -2] </FONT></B>

Leave out the fourth argument if no response is to be sent:
<B><FONT COLOR="PURPLE">	["call", "setline", ["$", ["one", "two", "three"]]] </FONT></B>

==============================================================================

6. Using a RAW or NL <A HREF="#channel">channel</A>				*<A NAME="channel-raw"></A><B>channel-raw</B>*

If mode is RAW or NL then a message can be sent like this:
<B>    let response = ch_evalraw(channel, {string})</B>

The {string} is sent as-is.  The response will be what can be read from the
<A HREF="#channel">channel</A> right away.  Since Vim doesn't know how to recognize the end of the
message you need to take care of <A HREF="motion.html#it">it</A> yourself.  The timeout applies for reading
the first byte, after that <A HREF="motion.html#it">it</A> will not wait for anything more.

If mode is &quot;nl&quot; you can send a message in a similar way.  You are expected
to put in the NL after each message.  Thus you can also send several <A HREF="message.html#messages">messages</A>
ending in a NL at once.  The response will be the text up to and including the
first NL.  This can also be just the NL for an empty response.
If no NL was read before the <A HREF="#channel">channel</A> timeout an empty <A HREF="eval.html#string">string</A> is returned.

To send a message, without expecting a response:
<B>    call ch_sendraw(channel, {string})</B>
The process can send back a response, the <A HREF="#channel">channel</A> handler will be called with
<A HREF="motion.html#it">it</A>.

To send a message and letting the response handled by a specific function,
asynchronously:
<B>    call ch_sendraw(channel, {string}, {'callback': 'MyHandler'})</B>

This {string} can also be JSON, use |<A HREF="eval.html#json_encode()">json_encode()</A>| to create <A HREF="motion.html#it">it</A> and
|<A HREF="eval.html#json_decode()">json_decode()</A>| to handle a received JSON message.

It is not possible to use |<A HREF="eval.html#ch_evalexpr()">ch_evalexpr()</A>| or |<A HREF="eval.html#ch_sendexpr()">ch_sendexpr()</A>| on a raw <A HREF="#channel">channel</A>.

A <A HREF="eval.html#String">String</A> in Vim cannot contain NUL bytes.  To send or receive NUL bytes read
or write from a buffer.  See |<A HREF="#in_io-buffer">in_io-buffer</A>| and |<A HREF="#out_io-buffer">out_io-buffer</A>|.

==============================================================================

7. More <A HREF="#channel">channel</A> <A HREF="eval.html#functions">functions</A>				*<A NAME="channel-more"></A><B>channel-more</B>*

To obtain the status of a <A HREF="#channel">channel</A>: ch_status(channel).  The possible results
are:
	&quot;fail&quot;		Failed to open the <A HREF="#channel">channel</A>.
	&quot;open&quot;		The <A HREF="#channel">channel</A> can be used.
	&quot;buffered&quot;	The <A HREF="#channel">channel</A> was closed but there is data to read.
	&quot;closed&quot;	The <A HREF="#channel">channel</A> was closed.

To obtain the <A HREF="#job">job</A> associated with a <A HREF="#channel">channel</A>: ch_getjob(channel)

To read one message from a <A HREF="#channel">channel</A>:
<B>	let output = ch_read(channel)</B>
This uses the <A HREF="#channel">channel</A> timeout.  To read without a timeout, just get any
message that is available:
<B>	let output = ch_read(channel, {'timeout': 0})</B>
When no message was available then the result is <A HREF="eval.html#v:none">v:none</A> for a JSON or JS mode
channels, an empty <A HREF="eval.html#string">string</A> for a RAW or NL <A HREF="#channel">channel</A>.  You can use |<A HREF="eval.html#ch_canread()">ch_canread()</A>|
to check if there is something to read.

Note that when there is no callback, <A HREF="message.html#messages">messages</A> are dropped.  To avoid that add
a close callback to the <A HREF="#channel">channel</A>.

To read all output from a RAW <A HREF="#channel">channel</A> that is available:
<B>	let output = ch_readraw(channel)</B>
To read the error output:
<B>	let output = ch_readraw(channel, {"part": "err"})</B>

<A HREF="eval.html#ch_read()">ch_read()</A> and <A HREF="eval.html#ch_readraw()">ch_readraw()</A> use the <A HREF="#channel">channel</A> timeout.  When there is nothing to
read within that time an empty <A HREF="eval.html#string">string</A> is returned.  To specify a different
timeout in msec use the &quot;timeout&quot; option:
<B><FONT COLOR="PURPLE">	{"timeout": 123} </FONT></B>
To read from the error output use the &quot;part&quot; option:
<B><FONT COLOR="PURPLE">	{"part": "err"} </FONT></B>
To read a message with a specific ID, on a JS or JSON <A HREF="#channel">channel</A>:
<B><FONT COLOR="PURPLE">	{"id": 99} </FONT></B>
When no ID is specified or the ID is -1, the first message is returned. This
overrules any callback waiting for this message.

For a RAW <A HREF="#channel">channel</A> this returns whatever is available, since Vim does not know
where a message ends.
For a NL <A HREF="#channel">channel</A> this returns one message.
For a JS or JSON <A HREF="#channel">channel</A> this returns one decoded message.
This includes any sequence number.

==============================================================================

8. Starting a <A HREF="#job">job</A> with a <A HREF="#channel">channel</A>			*<A NAME="job-start"></A><B>job-start</B>* *<A NAME="job"></A><B>job</B>*

To start a <A HREF="#job">job</A> and open a <A HREF="#channel">channel</A> for stdin/stdout/stderr:
<B>    let job = job_start(command, {options})</B>

You can get the <A HREF="#channel">channel</A> with:
<B>    let channel = job_getchannel(job)</B>

The <A HREF="#channel">channel</A> will use NL mode.  If you want another mode it's best to specify
this in {options}.  When <A HREF="change.html#changing">changing</A> the mode later some text may have already
been received and not parsed correctly.

If the command produces a line of output that you want to deal with, specify
a handler for stdout:
<B>    let job = job_start(command, {"out_cb": "MyHandler"})</B>
The function will be called with the <A HREF="#channel">channel</A> and a message. You would define
<A HREF="motion.html#it">it</A> like this:
<B>    func MyHandler(channel, msg)</B>

Without the handler you need to read the output with |<A HREF="eval.html#ch_read()">ch_read()</A>| or
|<A HREF="eval.html#ch_readraw()">ch_readraw()</A>|. You can <A HREF="diff.html#do">do</A> this in the close callback, see |<A HREF="#read-in-close-cb">read-in-close-cb</A>|.

Note that if the <A HREF="#job">job</A> exits before you read the output, the output may be lost.
This depends on the system (on <A HREF="os_unix.html#Unix">Unix</A> this happens because closing the write end
of a pipe causes the read end to get EOF).  To avoid this make the <A HREF="#job">job</A> sleep
for a short while before <A HREF="motion.html#it">it</A> exits.

The handler defined for &quot;<A HREF="#out_cb">out_cb</A>&quot; will not receive stderr.  If you want to
handle that separately, add an &quot;<A HREF="#err_cb">err_cb</A>&quot; handler:
<B>    let job = job_start(command, {"out_cb": "MyHandler",</B>
<B>	    \			  "err_cb": "ErrHandler"})</B>

If you want to handle both stderr and stdout with one handler use the
&quot;callback&quot; option:
<B>    let job = job_start(command, {"callback": "MyHandler"}) </B>

Depending on the system, starting a <A HREF="#job">job</A> can put Vim in the background, the
started <A HREF="#job">job</A> gets the focus.  To avoid that, use the `foreground()` function.
This might not always work when called early, put in the callback handler or
use a <A HREF="eval.html#timer">timer</A> to call <A HREF="motion.html#it">it</A> after the <A HREF="#job">job</A> has started.

You can send a message to the command with <A HREF="eval.html#ch_evalraw()">ch_evalraw()</A>.  If the <A HREF="#channel">channel</A> is in
JSON or JS mode you can use <A HREF="eval.html#ch_evalexpr()">ch_evalexpr()</A>.

There are several options you can use, see |<A HREF="#job-options">job-options</A>|.
For example, to start a <A HREF="#job">job</A> and write its output in buffer &quot;dummy&quot;:
<B>	let logjob = job_start("tail -f /tmp/log",</B>
<B>			     \ {'out_io': 'buffer', 'out_name': 'dummy'})</B>
<B>	sbuf dummy</B>


<B><FONT COLOR="PURPLE">Job input from a buffer </FONT></B>

							*<A NAME="in_io-buffer"></A><B>in_io-buffer</B>*
To run a <A HREF="#job">job</A> that reads from a buffer:
<B>	let job = job_start({command},</B>
<B>	    \ {'in_io': 'buffer', 'in_name': 'mybuffer'})</B>
 

							*<A NAME="E915"></A><B>E915</B>* *<A NAME="E918"></A><B>E918</B>*
The buffer is found by name, similar to |<A HREF="eval.html#bufnr()">bufnr()</A>|. The buffer must exist and
be loaded when <A HREF="eval.html#job_start()">job_start()</A> is called.

By default this reads the whole buffer.  This can be changed with the &quot;<A HREF="#in_top">in_top</A>&quot;
and &quot;<A HREF="#in_bot">in_bot</A>&quot; <A HREF="options.html#options">options</A>.

A special mode is when &quot;<A HREF="#in_top">in_top</A>&quot; is set to zero and &quot;<A HREF="#in_bot">in_bot</A>&quot; is not set: Every
time a line is added to the buffer, the last-but-one line will be sent to the
<A HREF="#job">job</A> stdin.  This allows for editing the last line and sending <A HREF="motion.html#it">it</A> when pressing
Enter.

							*<A NAME="channel-close-in"></A><B>channel-close-in</B>*
When not using the special mode the pipe or socket will be closed after the
last line has been written.  This signals the reading end that the input
finished.  You can also use |<A HREF="eval.html#ch_close_in()">ch_close_in()</A>| to close <A HREF="motion.html#it">it</A> sooner.

NUL bytes in the text will be passed to the <A HREF="#job">job</A> (internally Vim stores these
<A HREF="motion.html#as">as</A> NL bytes).


<B><FONT COLOR="PURPLE">Reading job output in the close callback </FONT></B>

							*<A NAME="read-in-close-cb"></A><B>read-in-close-cb</B>*
If the <A HREF="#job">job</A> can take some time and you don't need intermediate results, you can
add a close callback and read the output there:

<B>	func! CloseHandler(channel)</B>
<B>	  while ch_status(a:channel, {'part': 'out'}) == 'buffered'</B>
<B>	    echomsg ch_read(a:channel)</B>
<B>	  endwhile</B>
<B>	endfunc</B>
<B>	let job = job_start(command, {'close_cb': 'CloseHandler'})</B>

You will want to <A HREF="diff.html#do">do</A> something more useful than &quot;echomsg&quot;.

==============================================================================

9. Starting a <A HREF="#job">job</A> without a <A HREF="#channel">channel</A>			*<A NAME="job-start-nochannel"></A><B>job-start-nochannel</B>*

To start another process without creating a <A HREF="#channel">channel</A>:
<B>    let job = job_start(command,</B>
<B>	\ {"in_io": "null", "out_io": "null", "err_io": "null"})</B>

This starts {command} in the background, Vim does not wait for <A HREF="motion.html#it">it</A> to finish.

When Vim sees that neither stdin, stdout or stderr are connected, no <A HREF="#channel">channel</A>
will be created.  Often you will want to include redirection in the command to
avoid <A HREF="motion.html#it">it</A> getting stuck.

There are several options you can use, see |<A HREF="#job-options">job-options</A>|.


							*<A NAME="job-start-if-needed"></A><B>job-start-if-needed</B>*
To start a <A HREF="#job">job</A> only when connecting to an address does not work, <A HREF="diff.html#do">do</A> something
like this:
<B>	let channel = ch_open(address, {"waittime": 0})</B>
<B>	if ch_status(channel) == "fail"</B>
<B>	  let job = job_start(command)</B>
<B>	  let channel = ch_open(address, {"waittime": 1000})</B>
<B>	endif</B>

Note that the <A HREF="#waittime">waittime</A> for <A HREF="eval.html#ch_open()">ch_open()</A> gives the <A HREF="#job">job</A> one second to make the port
available.

==============================================================================

10. <A HREF="eval.html#Job">Job</A> <A HREF="options.html#options">options</A>						*<A NAME="job-options"></A><B>job-options</B>*

The {options} argument in <A HREF="eval.html#job_start()">job_start()</A> is a dictionary.  All entries are
optional.  Some <A HREF="options.html#options">options</A> can be used after the <A HREF="#job">job</A> has started, using
job_setoptions(job, {options}).  Many <A HREF="options.html#options">options</A> can be used with the <A HREF="#channel">channel</A>
related to the <A HREF="#job">job</A>, using ch_setoptions(channel, {options}).
See |<A HREF="eval.html#job_setoptions()">job_setoptions()</A>| and |<A HREF="eval.html#ch_setoptions()">ch_setoptions()</A>|.


						*<A NAME="in_mode"></A><B>in_mode</B>* *<A NAME="out_mode"></A><B>out_mode</B>* *<A NAME="err_mode"></A><B>err_mode</B>*
&quot;<A HREF="#in_mode">in_mode</A>&quot;		mode specifically for stdin, only when using pipes
&quot;<A HREF="#out_mode">out_mode</A>&quot;		mode specifically for stdout, only when using pipes
&quot;<A HREF="#err_mode">err_mode</A>&quot;		mode specifically for stderr, only when using pipes
			See |<A HREF="#channel-mode">channel-mode</A>| for the values.

			Note: when setting &quot;mode&quot; the part specific mode is
			overwritten.  Therefore set &quot;mode&quot; first and the part
			specific mode later.

			Note: when <A HREF="editing.html#writing">writing</A> to a file or buffer and when
			reading from a buffer NL mode is used by default.


						*<A NAME="job-noblock"></A><B>job-noblock</B>*
&quot;noblock&quot;: 1		When <A HREF="editing.html#writing">writing</A> use a non-blocking write call.  This
			avoids getting stuck if Vim should handle other
			<A HREF="message.html#messages">messages</A> in between, e.g. when a <A HREF="#job">job</A> sends back data
			to Vim.  It implies that when `ch_sendraw()` returns
			not all data may have been written yet.
			This option was added in patch 8.1.0350, test with:
<B>				if has("patch-8.1.350")</B>
<B>				  let options['noblock'] = 1</B>
<B>				endif</B>
 

						*<A NAME="job-callback"></A><B>job-callback</B>*
&quot;callback&quot;: handler	Callback for something to read on any part of the
			<A HREF="#channel">channel</A>.

						*<A NAME="job-out_cb"></A><B>job-out_cb</B>* *<A NAME="out_cb"></A><B>out_cb</B>*
&quot;<A HREF="#out_cb">out_cb</A>&quot;: handler	Callback for when there is something to read on
			stdout.  Only for when the <A HREF="#channel">channel</A> uses pipes.  When
			&quot;<A HREF="#out_cb">out_cb</A>&quot; wasn't set the <A HREF="#channel">channel</A> callback is used.
			The two arguments are the <A HREF="#channel">channel</A> and the message.


						*<A NAME="job-err_cb"></A><B>job-err_cb</B>* *<A NAME="err_cb"></A><B>err_cb</B>*
&quot;<A HREF="#err_cb">err_cb</A>&quot;: handler	Callback for when there is something to read on
			stderr.  Only for when the <A HREF="#channel">channel</A> uses pipes.  When
			&quot;<A HREF="#err_cb">err_cb</A>&quot; wasn't set the <A HREF="#channel">channel</A> callback is used.
			The two arguments are the <A HREF="#channel">channel</A> and the message.

						*<A NAME="job-close_cb"></A><B>job-close_cb</B>*
&quot;<A HREF="#close_cb">close_cb</A>&quot;: handler	Callback for when the <A HREF="#channel">channel</A> is closed.  Same <A HREF="motion.html#as">as</A>
			&quot;close_cb&quot; on |<A HREF="eval.html#ch_open()">ch_open()</A>|, see |<A HREF="#close_cb">close_cb</A>|.

						*<A NAME="job-drop"></A><B>job-drop</B>*
&quot;drop&quot;: when		Specifies when to drop <A HREF="message.html#messages">messages</A>.  Same <A HREF="motion.html#as">as</A> &quot;drop&quot; on
			|<A HREF="eval.html#ch_open()">ch_open()</A>|, see |<A HREF="#channel-drop">channel-drop</A>|.  For &quot;auto&quot; the
			exit_cb is not considered.

						*<A NAME="job-exit_cb"></A><B>job-exit_cb</B>*
&quot;exit_cb&quot;: handler	Callback for when the <A HREF="#job">job</A> ends.  The arguments are the
			<A HREF="#job">job</A> and the exit status.
			Vim checks up to 10 times per second for jobs that
			ended.  The check can also be triggered by calling
			|<A HREF="eval.html#job_status()">job_status()</A>|, which may then invoke the exit_cb
			handler.
			Note that data can be buffered, callbacks may still be
			called after the process ends.

							*<A NAME="job-timeout"></A><B>job-timeout</B>*
&quot;timeout&quot;: time		The time to wait for a request when blocking, E.g.
			when using <A HREF="eval.html#ch_evalexpr()">ch_evalexpr()</A>.  In milliseconds.  The
			default is 2000 (2 seconds).

						*<A NAME="out_timeout"></A><B>out_timeout</B>* *<A NAME="err_timeout"></A><B>err_timeout</B>*
&quot;<A HREF="#out_timeout">out_timeout</A>&quot;: time	Timeout for stdout.  Only when using pipes.
&quot;<A HREF="#err_timeout">err_timeout</A>&quot;: time	Timeout for stderr.  Only when using pipes.
			Note: when setting &quot;timeout&quot; the part specific mode is
			overwritten.  Therefore set &quot;timeout&quot; first and the
			part specific mode later.


						*<A NAME="job-stoponexit"></A><B>job-stoponexit</B>*
&quot;stoponexit&quot;: {signal}	Send {signal} to the <A HREF="#job">job</A> when Vim exits.  See
			|<A HREF="eval.html#job_stop()">job_stop()</A>| for possible values.
&quot;stoponexit&quot;: &quot;&quot;	Do not stop the <A HREF="#job">job</A> when Vim exits.
			The default is &quot;term&quot;.


						*<A NAME="job-term"></A><B>job-term</B>*
&quot;term&quot;: &quot;open&quot;		Start a <A HREF="terminal.html#terminal">terminal</A> in a new <A HREF="windows.html#window">window</A> and connect the <A HREF="#job">job</A>
			stdin/stdout/stderr to <A HREF="motion.html#it">it</A>.  Similar to using
			`:terminal`.
			NOTE: Not implemented yet!

&quot;<A HREF="#channel">channel</A>&quot;: {channel}	Use an existing <A HREF="#channel">channel</A> instead of creating a new one.
			The parts of the <A HREF="#channel">channel</A> that get used for the new <A HREF="#job">job</A>
			will be disconnected from what they were used before.
			If the <A HREF="#channel">channel</A> was still used by another <A HREF="#job">job</A> this may
			cause I/O <A HREF="message.html#errors">errors</A>.
			Existing callbacks and other settings remain.

&quot;pty&quot;: 1		Use a pty (pseudo-tty) instead of a pipe when
			possible.  This is most useful in combination with a
			terminal <A HREF="windows.html#window">window</A>, see |<A HREF="terminal.html#terminal">terminal</A>|.
			{only on <A HREF="os_unix.html#Unix">Unix</A> and Unix-like systems}


				*<A NAME="job-in_io"></A><B>job-in_io</B>* *<A NAME="in_top"></A><B>in_top</B>* *<A NAME="in_bot"></A><B>in_bot</B>* *<A NAME="in_name"></A><B>in_name</B>* *<A NAME="in_buf"></A><B>in_buf</B>*
&quot;in_io&quot;: &quot;null&quot;		disconnect stdin (read from /dev/null)
&quot;in_io&quot;: &quot;pipe&quot;		stdin is connected to the <A HREF="#channel">channel</A> (default)
&quot;in_io&quot;: &quot;file&quot;		stdin reads from a file
&quot;in_io&quot;: &quot;buffer&quot;	stdin reads from a buffer
&quot;<A HREF="#in_top">in_top</A>&quot;: number	when using &quot;buffer&quot;: first line to send (default: 1)
&quot;<A HREF="#in_bot">in_bot</A>&quot;: number	when using &quot;buffer&quot;: last line to send (default: last)
&quot;<A HREF="#in_name">in_name</A>&quot;: &quot;/path/file&quot;	the name of the file or buffer to read from
&quot;<A HREF="#in_buf">in_buf</A>&quot;: number	the number of the buffer to read from


				*<A NAME="job-out_io"></A><B>job-out_io</B>* *<A NAME="out_name"></A><B>out_name</B>* *<A NAME="out_buf"></A><B>out_buf</B>*
&quot;out_io&quot;: &quot;null&quot;	disconnect stdout (goes to /dev/null)
&quot;out_io&quot;: &quot;pipe&quot;	stdout is connected to the <A HREF="#channel">channel</A> (default)
&quot;out_io&quot;: &quot;file&quot;	stdout writes to a file
&quot;out_io&quot;: &quot;buffer&quot;	stdout appends to a buffer (see below)
&quot;<A HREF="#out_name">out_name</A>&quot;: &quot;/path/file&quot; the name of the file or buffer to write to
&quot;<A HREF="#out_buf">out_buf</A>&quot;: number	the number of the buffer to write to
&quot;<A HREF="#out_modifiable">out_modifiable</A>&quot;: 0	when <A HREF="editing.html#writing">writing</A> to a buffer, <A HREF="options.html#'modifiable'">'modifiable'</A> will be off
			(see below)
&quot;<A HREF="#out_msg">out_msg</A>&quot;: 0		when <A HREF="editing.html#writing">writing</A> to a new buffer, the first line will be
			set to &quot;Reading from <A HREF="#channel">channel</A> output...&quot;


				*<A NAME="job-err_io"></A><B>job-err_io</B>* *<A NAME="err_name"></A><B>err_name</B>* *<A NAME="err_buf"></A><B>err_buf</B>*
&quot;err_io&quot;: &quot;out&quot;		stderr <A HREF="message.html#messages">messages</A> to go to stdout
&quot;err_io&quot;: &quot;null&quot;	disconnect stderr  (goes to /dev/null)
&quot;err_io&quot;: &quot;pipe&quot;	stderr is connected to the <A HREF="#channel">channel</A> (default)
&quot;err_io&quot;: &quot;file&quot;	stderr writes to a file
&quot;err_io&quot;: &quot;buffer&quot;	stderr appends to a buffer (see below)
&quot;<A HREF="#err_name">err_name</A>&quot;: &quot;/path/file&quot; the name of the file or buffer to write to
&quot;<A HREF="#err_buf">err_buf</A>&quot;: number	the number of the buffer to write to
&quot;<A HREF="#err_modifiable">err_modifiable</A>&quot;: 0	when <A HREF="editing.html#writing">writing</A> to a buffer, <A HREF="options.html#'modifiable'">'modifiable'</A> will be off
			(see below)
&quot;<A HREF="#err_msg">err_msg</A>&quot;: 0		when <A HREF="editing.html#writing">writing</A> to a new buffer, the first line will be
			set to &quot;Reading from <A HREF="#channel">channel</A> error...&quot;

&quot;block_write&quot;: number	only for <A HREF="eval.html#testing">testing</A>: pretend every other write to stdin
			will block

&quot;env&quot;: <A HREF="eval.html#dict">dict</A>		environment <A HREF="eval.html#variables">variables</A> for the new process
&quot;cwd&quot;: &quot;/path/to/dir&quot;	current working directory for the new process;
			if the directory does not exist an error is given


<B><FONT COLOR="PURPLE">Writing to a buffer </FONT></B>

							*<A NAME="out_io-buffer"></A><B>out_io-buffer</B>*
When the out_io or err_io mode is &quot;buffer&quot; and there is a callback, the text
is appended to the buffer before invoking the callback.

When a buffer is used both for input and output, the output lines are put
above the last line, since the last line is what is written to the <A HREF="#channel">channel</A>
input.  Otherwise lines are appended below the last line.

When using JS or JSON mode with &quot;buffer&quot;, only <A HREF="message.html#messages">messages</A> with zero or negative
ID will be added to the buffer, after decoding + encoding.  Messages with a
positive number will be handled by a callback, commands are handled <A HREF="motion.html#as">as</A> usual.

The name of the buffer from &quot;<A HREF="#out_name">out_name</A>&quot; or &quot;<A HREF="#err_name">err_name</A>&quot; is compared the full name
of existing <A HREF="windows.html#buffers">buffers</A>, also after expanding the name for the current directory.
E.g., when a buffer was created with &quot;<A HREF="editing.html#:edit">:edit</A> somename&quot; and the buffer name is
&quot;somename&quot; <A HREF="motion.html#it">it</A> will use that buffer.

If there is no matching buffer a new buffer is created.  Use an empty name to
always create a new buffer.  |<A HREF="eval.html#ch_getbufnr()">ch_getbufnr()</A>| can then be used to get the
buffer number.

For a new buffer <A HREF="options.html#'buftype'">'buftype'</A> is set to &quot;nofile&quot; and <A HREF="options.html#'bufhidden'">'bufhidden'</A> to &quot;hide&quot;.  If
you prefer other settings, create the buffer first and pass the buffer number.

					*<A NAME="out_modifiable"></A><B>out_modifiable</B>* *<A NAME="err_modifiable"></A><B>err_modifiable</B>*
The &quot;<A HREF="#out_modifiable">out_modifiable</A>&quot; and &quot;<A HREF="#err_modifiable">err_modifiable</A>&quot; <A HREF="options.html#options">options</A> can be used to set the
<A HREF="options.html#'modifiable'">'modifiable'</A> option off, or write to a buffer that has <A HREF="options.html#'modifiable'">'modifiable'</A> off.  That
means that lines will be appended to the buffer, but the user can't easily
change the buffer.

					*<A NAME="out_msg"></A><B>out_msg</B>* *<A NAME="err_msg"></A><B>err_msg</B>*
The &quot;<A HREF="#out_msg">out_msg</A>&quot; option can be used to specify whether a new buffer will have the
first line set to &quot;Reading from <A HREF="#channel">channel</A> output...&quot;.  The default is to add the
message.  &quot;<A HREF="#err_msg">err_msg</A>&quot; does the same for <A HREF="#channel">channel</A> error.

When an existing buffer is to be written where <A HREF="options.html#'modifiable'">'modifiable'</A> is off and the
&quot;<A HREF="#out_modifiable">out_modifiable</A>&quot; or &quot;<A HREF="#err_modifiable">err_modifiable</A>&quot; <A HREF="options.html#options">options</A> is not zero, an error is given
and the buffer will not be written to.

When the buffer written to is displayed in a <A HREF="windows.html#window">window</A> and the cursor is in the
first column of the last line, the cursor will be moved to the newly added
line and the <A HREF="windows.html#window">window</A> is scrolled up to show the cursor if needed.

Undo is synced for every added line.  NUL bytes are accepted (internally Vim
stores these <A HREF="motion.html#as">as</A> NL bytes).


<B><FONT COLOR="PURPLE">Writing to a file </FONT></B>

							*<A NAME="E920"></A><B>E920</B>*
The file is created with permissions 600 (read-write for the user, not
accessible for others).  Use |<A HREF="eval.html#setfperm()">setfperm()</A>| to change this.

If the file already exists <A HREF="motion.html#it">it</A> is truncated.

==============================================================================

11. Controlling a <A HREF="#job">job</A>					*<A NAME="job-control"></A><B>job-control</B>*

To get the status of a <A HREF="#job">job</A>:
<B>	echo job_status(job)</B>

To make a <A HREF="#job">job</A> stop running:
<B>	job_stop(job)</B>

This is the normal way to end a <A HREF="#job">job</A>. On <A HREF="os_unix.html#Unix">Unix</A> <A HREF="motion.html#it">it</A> sends a SIGTERM to the <A HREF="#job">job</A>.
It is possible to use other ways to stop the <A HREF="#job">job</A>, or even send arbitrary
signals.  E.g. to force a <A HREF="#job">job</A> to stop, &quot;kill it&quot;:
<B>	job_stop(job, "kill")</B>

For more <A HREF="options.html#options">options</A> see |<A HREF="eval.html#job_stop()">job_stop()</A>|.

==============================================================================

12. Using a prompt buffer				*<A NAME="prompt-buffer"></A><B>prompt-buffer</B>*

If you want to type input for the <A HREF="#job">job</A> in a Vim <A HREF="windows.html#window">window</A> you have a few <A HREF="options.html#options">options</A>:
- Use a normal buffer and handle all possible commands yourself.
  This will be complicated, since there are so many possible commands.
- Use a <A HREF="terminal.html#terminal">terminal</A> <A HREF="windows.html#window">window</A>.  This works well if what you type goes directly to
  the <A HREF="#job">job</A> and the <A HREF="#job">job</A> output is directly displayed in the <A HREF="windows.html#window">window</A>.
  See |<A HREF="terminal.html#terminal-window">terminal-window</A>|.
- Use a prompt <A HREF="windows.html#window">window</A>. This works well when entering a line for the <A HREF="#job">job</A> in Vim
  while displaying (possibly filtered) output from the <A HREF="#job">job</A>.

A prompt buffer is created by setting <A HREF="options.html#'buftype'">'buftype'</A> to &quot;prompt&quot;. You would
normally only <A HREF="diff.html#do">do</A> that in a newly created buffer.

The user can edit and enter one line of text at the very last line of the
buffer.  When pressing Enter in the prompt line the callback set with
|<A HREF="eval.html#prompt_setcallback()">prompt_setcallback()</A>| is invoked.  It would normally send the line to a <A HREF="#job">job</A>.
Another callback would receive the output from the <A HREF="#job">job</A> and display <A HREF="motion.html#it">it</A> in the
buffer, below the prompt (and above the next prompt).

Only the text in the last line, after the prompt, is editable. The rest of the
buffer is not modifiable with <A HREF="intro.html#Normal">Normal</A> mode commands.  It can be modified by
calling <A HREF="eval.html#functions">functions</A>, such <A HREF="motion.html#as">as</A> |<A HREF="eval.html#append()">append()</A>|.  Using other commands may mess up the
buffer.

After setting <A HREF="options.html#'buftype'">'buftype'</A> to &quot;prompt&quot; Vim does not automatically start <A HREF="insert.html#Insert">Insert</A>
mode, use `:startinsert` if you want to enter <A HREF="insert.html#Insert">Insert</A> mode, so that the user
can start typing a line.

The text of the prompt can be set with the |<A HREF="eval.html#prompt_setprompt()">prompt_setprompt()</A>| function.

The user can go to <A HREF="intro.html#Normal">Normal</A> mode and navigate through the buffer.  This can be
useful see older output or copy text.

The <A HREF="index.html#CTRL-W">CTRL-W</A> key can be used to start a <A HREF="windows.html#window">window</A> command, such <A HREF="motion.html#as">as</A> <A HREF="index.html#CTRL-W">CTRL-W</A> <A HREF="motion.html#w">w</A> to
switch to the next <A HREF="windows.html#window">window</A>.  This also works in <A HREF="insert.html#Insert">Insert</A> mode (use Shift-CTRL-W
to delete a <A HREF="motion.html#word">word</A>). When leaving the <A HREF="windows.html#window">window</A> <A HREF="insert.html#Insert">Insert</A> mode will be stopped.  When
coming back to the prompt <A HREF="windows.html#window">window</A> <A HREF="insert.html#Insert">Insert</A> mode will be restored.

Any command that starts <A HREF="insert.html#Insert">Insert</A> mode, such <A HREF="motion.html#as">as</A> &quot;<A HREF="insert.html#a">a</A>&quot;, &quot;<A HREF="insert.html#i">i</A>&quot;, &quot;<A HREF="insert.html#A">A</A>&quot; and &quot;<A HREF="insert.html#I">I</A>&quot;, will move
the cursor to the last line.  &quot;<A HREF="insert.html#A">A</A>&quot; will move to the end of the line, &quot;<A HREF="insert.html#I">I</A>&quot; to the
start of the line.


<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
</BODY>


</HTML>
